var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = BetaRegression","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The exported symbols from this package define its interface. Some symbols from other packages are re-exported for convenience. Fields of objects with composite types should not be accessed directly; the internals of any given structure may change at any time and this would not be considered a breaking change.","category":"page"},{"location":"api/#Fitting-a-model","page":"API","title":"Fitting a model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BetaRegressionModel\nBetaRegressionModel(::AbstractMatrix, ::AbstractVector)\nfit(::Type{BetaRegressionModel}, ::AbstractMatrix, ::AbstractVector)\nfit!(::BetaRegressionModel)","category":"page"},{"location":"api/#BetaRegression.BetaRegressionModel","page":"API","title":"BetaRegression.BetaRegressionModel","text":"BetaRegressionModel{T,L1,L2,V,M} <: RegressionModel\n\nType representing a regression model for beta-distributed response values in the open interval (0, 1), as described by Ferrari and Cribari-Neto (2004).\n\nThe mean response is linked to the linear predictor by a link function with type L1 <: Link01, i.e. the link must map (0 1) mapsto mathbbR and use the GLM package's interface for link functions. While there is no canonical link function for the beta regression model as there is for GLMs, logit is the most common choice.\n\nThe precision is transformed by a link function with type L2 <: Link which should map mathbbR mapsto mathbbR or, ideally, (0 infty) mapsto mathbbR because the precision must be positive. The most common choices are the identity, log, and square root links.\n\n\n\n\n\n","category":"type"},{"location":"api/#BetaRegression.BetaRegressionModel-Tuple{AbstractMatrix, AbstractVector}","page":"API","title":"BetaRegression.BetaRegressionModel","text":"BetaRegressionModel(X, y, link=LogitLink(), precisionlink=IdentityLink();\n                    weights=nothing, offset=nothing)\n\nConstruct a BetaRegressionModel object with the given model matrix X, response y, mean link function link, precision link function precisionlink, and optionally weights and offset. Note that the returned object is not fit until fit! is called on it.\n\nwarning: Warning\nSupport for user-provided weights is currently incomplete; passing a value other than nothing or an empty array for weights will result in an error for now.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Tuple{Type{BetaRegressionModel}, AbstractMatrix, AbstractVector}","page":"API","title":"StatsAPI.fit","text":"fit(BetaRegressionModel, formula, data, link=LogitLink(), precisionlink=IdentityLink();\n    kwargs...)\n\nFit a BetaRegressionModel to the given table data, which may be any Tables.jl-compatible table (e.g. a DataFrame), using the given formula, which can be constructed using @formula. In this method, the response and model matrix are determined from the formula and table. It is also possible to provide them explicitly.\n\nfit(BetaRegressionModel, X::AbstractMatrix, y::AbstractVector, link=LogitLink(),\n    precisionlink=IdentityLink(); kwargs...)\n\nFit a beta regression model using the provided model matrix X and response vector y. In both of these methods, a link function may be provided, otherwise the default logit link is used. Similarly, a link for the precision may be provided, otherwise the default identity link is used.\n\nKeyword Arguments\n\nweights: A vector of weights or nothing (default). Currently only nothing is accepted.\noffset: An offset vector to be added to the linear predictor or nothing (default).\nmaxiter: Maximum number of Fisher scoring iterations to use when fitting. Default is 100.\natol: Absolute tolerance to use when checking for model convergence. Default is sqrt(eps(T)) where T is the type of the estimates.\nrtol: Relative tolerance to use when checking for convergence. Default is the Base default relative tolerance for T.\n\ntip: Tip\nIf you experience convergence issues, you may consider trying a different link for the precision; LogLink() is a common choice. Increasing the maximum number of iterations may also be beneficial, especially when working with Float32.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit!-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.fit!","text":"fit!(b::BetaRegressionModel{T}; maxiter=100, atol=sqrt(eps(T)), rtol=Base.rtoldefault(T))\n\nFit the given BetaRegressionModel, updating its values in-place. If model convergence is achieved, b is returned, otherwise a ConvergenceException is thrown.\n\nFitting the model consists of computing the maximum likelihood estimates for the coefficients and precision parameter via Fisher scoring with analytic derivatives. The model is determined to have converged when the score vector, i.e. the vector of first partial derivatives of the log likelihood with respect to the parameters, is approximately zero. This is determined by isapprox using the specified atol and rtol. maxiter dictates the maximum number of Fisher scoring iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Properties-of-a-model","page":"API","title":"Properties of a model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"aic\naicc\nbic\ncoef(::BetaRegressionModel)\ncoefnames(::TableRegressionModel{<:BetaRegressionModel})\ncoeftable(::BetaRegressionModel)\nconfint(::BetaRegressionModel)\ndeviance(::BetaRegressionModel)\ndevresid(::BetaRegressionModel)\ndof(::BetaRegressionModel)\ndof_residual(::BetaRegressionModel)\nfitted\ninformationmatrix(::BetaRegressionModel)\nlinearpredictor\nLink(::BetaRegressionModel)\nloglikelihood\nmodelmatrix\nnobs(::BetaRegressionModel)\noffset\nparams(::BetaRegressionModel)\nprecision(::BetaRegressionModel)\nprecisionlink\npredict\nr2(::BetaRegressionModel)\nresiduals\nresponse\nresponsename(::TableRegressionModel{<:BetaRegressionModel})\nscore(::BetaRegressionModel)\nstderror(::BetaRegressionModel)\nvcov(::BetaRegressionModel)\nweights","category":"page"},{"location":"api/#StatsAPI.aic","page":"API","title":"StatsAPI.aic","text":"aic(model::StatisticalModel)\n\nAkaike's Information Criterion, defined as -2 log L + 2k, with L the likelihood of the model, and k its number of consumed degrees of freedom (as returned by dof).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.aicc","page":"API","title":"StatsAPI.aicc","text":"aicc(model::StatisticalModel)\n\nCorrected Akaike's Information Criterion for small sample sizes (Hurvich and Tsai 1989), defined as -2 log L + 2k + 2k(k-1)(n-k-1), with L the likelihood of the model, k its number of consumed degrees of freedom (as returned by dof), and n the number of observations (as returned by nobs).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.bic","page":"API","title":"StatsAPI.bic","text":"bic(model::StatisticalModel)\n\nBayesian Information Criterion, defined as -2 log L + k log n, with L the likelihood of the model,  k its number of consumed degrees of freedom (as returned by dof), and n the number of observations (as returned by nobs).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.coef-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.coef","text":"coef(model::BetaRegressionModel)\n\nReturn a copy of the vector of regression coefficients mathbfbeta.\n\nSee also: precision, params\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.coefnames-Tuple{StatsModels.TableRegressionModel{<:BetaRegressionModel}}","page":"API","title":"StatsAPI.coefnames","text":"coefnames(model::TableRegressionModel{<:BetaRegressionModel})\n\nFor a BetaRegressionModel fit using a table and @formula, return the names of the coefficients as a vector of strings. The precision term is included as the last element in the array and has name \"(Precision)\".\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.coeftable-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.coeftable","text":"coeftable(model::BetaRegressionModel; level=0.95)\n\nReturn a table of the point estimates of the model parameters, their respective standard errors, z-statistics, Wald p-values, and confidence intervals at the given level. The precision parameter is included as the last row in the table.\n\nThe object returned by this function implements the Tables.jl interface for tabular data.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.confint","text":"confint(model::BetaRegressionModel; level=0.95)\n\nFor a model with p regression coefficients, return a (p + 1) times 2 matrix of confidence intervals for the estimated coefficients and precision at the given level.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.deviance-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.deviance","text":"deviance(model::BetaRegressionModel)\n\nCompute the deviance of the model, defined as the sum of the squared deviance residuals.\n\nSee also: devresid\n\n\n\n\n\n","category":"method"},{"location":"api/#GLM.devresid-Tuple{BetaRegressionModel}","page":"API","title":"GLM.devresid","text":"devresid(model::BetaRegressionModel)\n\nCompute the signed deviance residuals of the model,\n\nmathrmsgn(y_i - haty_i) sqrt2 lvert ell(y_i hatphi) - ell(haty_i hatphi) rvert\n\nwhere ell denotes the log likelihood, y_i is the ith observed value of the response, haty_i is the ith fitted value, and hatphi is the estimated common precision parameter.\n\nSee also: deviance\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.dof-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.dof","text":"dof(model::BetaRegressionModel)\n\nReturn the number of estimated parameters in the model. For a model with p independent variables, this is p + 1, since the precision must also be estimated.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.dof_residual-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.dof_residual","text":"dof_residual(model::BetaRegressionModel)\n\nReturn the residual degrees of freedom for the model, defined as nobs minus dof.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fitted","page":"API","title":"StatsAPI.fitted","text":"fitted(model::RegressionModel)\n\nReturn the fitted values of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.informationmatrix-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.informationmatrix","text":"informationmatrix(model::BetaRegressionModel; expected=true)\n\nCompute the information matrix of the model. By default, this is the Fisher information, i.e. the expected value of the matrix of second partial derivatives of loglikelihood with respect to each element of params. Set expected to false to obtain the observed information.\n\nSee also: vcov, score\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.linearpredictor","page":"API","title":"StatsAPI.linearpredictor","text":"linearpredictor(model::RegressionModel)\n\nReturn the model's linear predictor, Xβ where X is the model matrix and β is the vector of coefficients, or Xβ + offset if the model was fit with an offset.\n\n\n\n\n\n","category":"function"},{"location":"api/#GLM.Link-Tuple{BetaRegressionModel}","page":"API","title":"GLM.Link","text":"Link(model::BetaRegressionModel)\n\nReturn the link function g that links the mean mu to the linear predictor eta by mu = g^-1(eta).\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.loglikelihood","page":"API","title":"StatsAPI.loglikelihood","text":"loglikelihood(model::StatisticalModel)\nloglikelihood(model::StatisticalModel, observation)\n\nReturn the log-likelihood of the model.\n\nWith an observation argument, return the contribution of observation to the log-likelihood of model.\n\nIf observation is a Colon, return a vector of each observation's contribution to the log-likelihood of the model. In other words, this is the vector of the pointwise log-likelihood contributions.\n\nIn general, sum(loglikehood(model, :)) == loglikelihood(model).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.modelmatrix","page":"API","title":"StatsAPI.modelmatrix","text":"modelmatrix(model::RegressionModel)\n\nReturn the model matrix (a.k.a. the design matrix).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.nobs-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.nobs","text":"nobs(model::BetaRegressionModel)\n\nReturn the effective number of observations used to fit the model. For weighted models, this is the number of nonzero weights, otherwise it's the number of elements of the response (or equivalently, the number of rows in the model matrix).\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.offset","page":"API","title":"StatsAPI.offset","text":"offset(model::RegressionModel)\n\nReturn the offset used in the model, i.e. the term added to the linear predictor with known coefficient 1, or nothing if the model was not fit with an offset.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.params-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.params","text":"params(model::BetaRegressionModel)\n\nReturn the vector of estimated model parameters theta = beta_1 ldots beta_p phi, i.e. the regression coefficients and precision.\n\ndanger: Danger\nMutating this array may invalidate the model object.\n\nSee also: coef, precision\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.precision-Tuple{BetaRegressionModel}","page":"API","title":"Base.precision","text":"precision(model::BetaRegressionModel)\n\nReturn the estimated precision parameter, phi, for the model. This function returns phi on the natural scale, not on the precision link scale. This parameter is estimated alongside the regression coefficients and is included in coefficient tables, where it is displayed on the precision link scale.\n\nSee also: coef, params\n\n\n\n\n\n","category":"method"},{"location":"api/#BetaRegression.precisionlink","page":"API","title":"BetaRegression.precisionlink","text":"precisionlink(model::BetaRegressionModel)\n\nReturn the link function h that links the precision phi to the estimated constant parameter theta_p+1 such that phi = h^-1(theta_p+1).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.predict","page":"API","title":"StatsAPI.predict","text":"predict(model::RegressionModel, [newX])\n\nForm the predicted response of model. An object with new covariate values newX can be supplied, which should have the same type and structure as that used to fit model; e.g. for a GLM it would generally be a DataFrame with the same variable names as the original predictors.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.r2-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.r2","text":"r2(model::BetaRegressionModel)\nr²(model::BetaRegressionModel)\n\nReturn the Pearson correlation between the linear predictor eta and the link-transformed response g(y).\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.residuals","page":"API","title":"StatsAPI.residuals","text":"residuals(model::RegressionModel)\n\nReturn the residuals of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.response","page":"API","title":"StatsAPI.response","text":"response(model::RegressionModel)\n\nReturn the model response (a.k.a. the dependent variable).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.responsename-Tuple{StatsModels.TableRegressionModel{<:BetaRegressionModel}}","page":"API","title":"StatsAPI.responsename","text":"responsename(model::TableRegressionModel{<:BetaRegressionModel})\n\nFor a BetaRegressionModel fit using a table and @formula, return a string containing the left hand side of the formula, i.e. the model's response.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.score-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.score","text":"score(model::BetaRegressionModel)\n\nCompute the score vector of the model, i.e. the vector of first partial derivatives of loglikelihood with respect to each element of params.\n\nSee also: informationmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.stderror-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.stderror","text":"stderror(model::BetaRegressionModel)\n\nReturn the standard errors of the estimated model parameters, including both the regression coefficients and the precision.\n\nSee also: vcov\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.vcov-Tuple{BetaRegressionModel}","page":"API","title":"StatsAPI.vcov","text":"vcov(model::BetaRegressionModel)\n\nCompute the variance-covariance matrix of the model, i.e. the inverse of the Fisher information matrix.\n\nSee also: stderror, informationmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.weights","page":"API","title":"StatsAPI.weights","text":"weights(model::StatisticalModel)\n\nReturn the weights used in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"There is a subtlety here that bears repeating. The function coef does not include the precision term, only the regression coefficients, so for a model with p independent variables, coef will return a vector of length p. A number of other functions, such as informationmatrix, vcov, stderror, etc., do include the precision term, and thus will return an array with (non-singleton) dimension p + 1. While this difference may seem strange at first blush, the design was chosen intentionally to ensure that the model matrix and regression coefficient vector are conformable for multiplication. Use params to retrieve the full parameter vector with length p + 1.","category":"page"},{"location":"api/#Link-functions","page":"API","title":"Link functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This package employs the system for link functions defined by the GLM.jl package. In short, each link function has its own concrete type which subtypes Link. Some may actually subtype Link01, which is itself a subtype of Link; this denotes that the function's domain is the open unit interval, (0 1). Link functions are applied with linkfun and their inverse is applied with linkinv. Relevant docstrings from GLM.jl are reproduced below.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Any mention of \"the\" link function for a BetaRegressionModel refers to that applied to the mean (at least in this document). However, despite only having one linear predictor, BetaRegressionModels actually have two link functions: one for the mean and one for the precision.","category":"page"},{"location":"api/#Mean","page":"API","title":"Mean","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Link01\nLogitLink\nCauchitLink\nCloglogLink\nProbitLink","category":"page"},{"location":"api/#GLM.Link01","page":"API","title":"GLM.Link01","text":"Link01\n\nAn abstract subtype of Link which are links defined on (0, 1)\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.LogitLink","page":"API","title":"GLM.LogitLink","text":"LogitLink\n\nThe canonical Link01 for Distributions.Bernoulli and Distributions.Binomial. The inverse link, linkinv, is the c.d.f. of the standard logistic distribution, Distributions.Logistic.\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.CauchitLink","page":"API","title":"GLM.CauchitLink","text":"CauchitLink\n\nA Link01 corresponding to the standard Cauchy distribution, Distributions.Cauchy.\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.CloglogLink","page":"API","title":"GLM.CloglogLink","text":"CloglogLink\n\nA Link01 corresponding to the extreme value (or log-Weibull) distribution.  The link is the complementary log-log transformation, log(1 - log(-μ)).\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.ProbitLink","page":"API","title":"GLM.ProbitLink","text":"ProbitLink\n\nA Link01 whose linkinv is the c.d.f. of the standard normal distribution, Distributions.Normal().\n\n\n\n\n\n","category":"type"},{"location":"api/#Precision","page":"API","title":"Precision","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"IdentityLink\nInverseLink\nInverseSquareLink\nLogLink\nPowerLink\nSqrtLink","category":"page"},{"location":"api/#GLM.IdentityLink","page":"API","title":"GLM.IdentityLink","text":"IdentityLink\n\nThe canonical Link for the Normal distribution, defined as η = μ.\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.InverseLink","page":"API","title":"GLM.InverseLink","text":"InverseLink\n\nThe canonical Link for Distributions.Gamma distribution, defined as η = inv(μ).\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.InverseSquareLink","page":"API","title":"GLM.InverseSquareLink","text":"InverseSquareLink\n\nThe canonical Link for Distributions.InverseGaussian distribution, defined as η = inv(abs2(μ)).\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.LogLink","page":"API","title":"GLM.LogLink","text":"LogLink\n\nThe canonical Link for Distributions.Poisson, defined as η = log(μ).\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.PowerLink","page":"API","title":"GLM.PowerLink","text":"PowerLink\n\nA Link defined as η = μ^λ when λ ≠ 0, and to η = log(μ) when λ = 0, i.e. the class of transforms that use a power function or logarithmic function.\n\nMany other links are special cases of PowerLink:\n\nIdentityLink when λ = 1.\nSqrtLink when λ = 0.5.\nLogLink when λ = 0.\nInverseLink when λ = -1.\nInverseSquareLink when λ = -2.\n\n\n\n\n\n","category":"type"},{"location":"api/#GLM.SqrtLink","page":"API","title":"GLM.SqrtLink","text":"SqrtLink\n\nA Link defined as η = √μ\n\n\n\n\n\n","category":"type"},{"location":"api/#Developer-documentation","page":"API","title":"Developer documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents some functions that are not user facing (and are thus not exported) and may be removed at any time. They're included here for the benefit of anyone looking to contribute to the package and wondering how certain internals work. Other internal functions may be documented with comments in the source code rather than with docstrings; read the source directly for more information on those.","category":"page"},{"location":"api/","page":"API","title":"API","text":"dmueta\ninitialize!","category":"page"},{"location":"api/#BetaRegression.dmueta","page":"API","title":"BetaRegression.dmueta","text":"dmueta(link::Link, η)\n\nReturn the second derivative of linkinv, fracpartial^2 mupartial eta^2, of the link function link evaluated at the linear predictor value η. A method of this function must be defined for a particular link function in order to compute the observed information matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#BetaRegression.initialize!","page":"API","title":"BetaRegression.initialize!","text":"initialize!(b::BetaRegressionModel)\n\nInitialize the given BetaRegressionModel by computing starting points for the parameter estimates and return the updated model object. The initial estimates are based on those from a linear regression model with the same model matrix as b but with linkfun.(Link(b), response(b)) as the response.\n\nIf the initial estimate of the precision is invalid (not strictly positive) then it is taken instead to be 1 prior to applying the precision link function.\n\n\n\n\n\n","category":"function"},{"location":"details/#Details","page":"Details","title":"Details","text":"","category":"section"},{"location":"details/#What-is-beta-regression?","page":"Details","title":"What is beta regression?","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Beta regression is a type of regression model similar to a generalized linear model (GLM) but with a couple of key differences. It was first described by Ferrari and Cribari-Neto (2004)[1] with later extensions by Vasconcellos and Cribari-Neto (2005)[2], Smithson and Verkuilen (2006)[3], Ospina et al. (2006)[4], and Simas et al. (2010)[5].","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Let's briefly review some high-level ideas behind GLMs, starting with notation.","category":"page"},{"location":"details/#A-bit-about-GLMs","page":"Details","title":"A bit about GLMs","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Let mathbfy in mathbbR^n be a vector of n observed outcomes and let mathbfX in mathbbR^n times p be a matrix of n measurements on p independent variables. Further, let y_i sim mathcalD(mu_i phi) for a distribution mathcalD with parameters mu_i and phi. That is, each observed outcome was generated from the same overall distribution but with possibly different means mu_i in mathbbR and a common precision parameter phi in mathbbR. We relate the mean vector boldsymbolmu to the independent variables via a link function g mathbbR mapsto mathbbR and a linear predictor boldsymboleta = mathbfX boldsymbolbeta such that mu_i = g^-1(eta_i). Here, boldsymbolbeta in mathbbR^p is a vector of regression coefficients to be estimated.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"GLMs were first described by Nelder and Wedderburn (1972)[6] and expanded upon in the classic book by McCullagh and Nelder (1989)[7]. Nelder and Wedderburn showed that under certain conditions, most notably when mathcalD is a member of the exponential family of distributions, the maximum likelihood estimate of boldsymbolbeta, denoted hatboldsymbolbeta, can be found by the method of iteratively reweighted least squares (IRLS). Within this framework, phi does not need to be estimated directly; it can be obtained simply from the deviance of the model, n, and p. This relies, however, on the orthogonality of boldsymbolbeta and phi. Indeed, orthogonality these parameters was proved for all GLMs by Huang and Rathouz (2017)[8], expanding upon much earlier results for specific models.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"In Julia, the canonical implementation of GLMs is in the package GLM.jl, which uses IRLS and supports specific distributions from the Distributions.jl package.","category":"page"},{"location":"details/#The-beta-distribution","page":"Details","title":"The beta distribution","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Our primary concern will be with the beta distribution, a continuous probability distribution with support on the open interval (0 1) and two positive real shape parameters p and q. It has probability density function","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"f(y p q) = fracy^p - 1 (1 - y)^q - 1Beta(p q)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"where Beta(cdot cdot) is the beta function. The beta distribution in this parameterization is available from Distributions.jl as Beta.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Ferrari and Cribari-Neto reparameterize the distribution in terms of a mean 0  mu  1 and precision phi  0 such that","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"mu = fracpp + q quad quad phi = p + q","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"In this parameterization, it's clear that mu and phi are not separable; indeed, phi appears in the denominator of mu's definition!","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"We then have, for y sim mathcalB(mu phi), where mathcalB is the beta distribution in this parameterization, the probability density function","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"f(y mu phi) =\n    fracy^mu phi - 1 (1 - y)^(1 - mu) phi - 1Beta(mu phi (1 - mu) phi)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"with","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"textE(y) = mu quad quad textVar(y) = fracmu (1 - mu)phi + 1","category":"page"},{"location":"details/#Beta-regression","page":"Details","title":"Beta regression","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"With all of these definitions in mind, we can now formulate the beta regression model. Assume now that","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"y_i sim mathcalB(g^-1(mathbfx_i^top boldsymbolbeta) h^-1(phi))\nquad quad i = 1 ldots n","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"where the link function for the mean mu is g (0 1) mapsto mathbbR, mathbfx_i^top is the ith row of mathbfX, and the link function for the precision phi is h (0 infty) mapsto mathbbR. Just like with GLMs, we're modeling mu as a function of the linear predictor and our ultimate goal is to estimate boldsymbolbeta. But since mu depends on phi, so does boldsymbolbeta! Thus to estimate boldsymbolbeta, we must also estimate phi, which is assumed to be an unknown constant.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Some formulations of the beta regression model use separate sub-models for the mean and precision with separate coefficients and possibly non-overlapping sets of independent variables, thereby not assuming constant precision. That is not implemented in this package. By analogy, what is implemented here is an intercept-only sub-model for the precision.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"We don't have to resort to anything fancy in order to fit beta regression models; we can simply use maximum likelihood on the full parameter vector for the model, which we define to be theta = beta_1 ldots beta_p phi.","category":"page"},{"location":"details/#Fitting-a-model","page":"Details","title":"Fitting a model","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"In BetaRegression.jl, the maximum likelihood estimation is carried out via Fisher scoring using closed-form expressions for the score vector and expected information matrix.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"The information matrix is symmetric with the following block structure:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"left\n    beginarraycccc\n        fracpartial^2 ellpartial beta_1^2  cdots \n        fracpartial^2 ellpartial beta_1 partial beta_p \n        fracpartial^2 ellpartial beta_1 partial phi \n        vdots  ddots  vdots  vdots \n        fracpartial^2 ellpartial beta_p partial beta_1  cdots \n        fracpartial^2 ellpartial beta_p^2 \n        fracpartial^2 ellpartial beta_p partial phi \n        hline \n        fracpartial^2 ellpartial phi partial beta_1  cdots \n        fracpartial^2 ellpartial phi partial beta_p \n        fracpartial^2 ellpartial phi^2\n    endarray\nright","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Since mu depends on phi, we have that mathbbEleft(fracpartial^2 ellpartial beta_i partial phiright) neq 0, so the matrix is not block diagonal.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"There is no canonical link function for the beta regression model in this parameterization in the same manner as for GLMs (anything that constrains mu within (0 1) will do just fine) but for simplicity and interpretability the default link function is logit. In the parlance of GLM.jl, this means that any Link01 can be used and the default is LogitLink.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Providing a separate link function for the precision can improve numerical stability when fitting models by naturally constraining the precision to be nonnegative. The default is the identity link function, or in GLM.jl terms, IdentityLink, but other common choices include the logarithm and square root links, LogLink and SqrtLink, respectively.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Mirroring the API for GLMs provided by GLM.jl, a beta regression model is fit by passing an explicit design matrix X and response vector y as in","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"fit(BetaRegressionModel, X, y, meanlink, precisionlink; kwargs...)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"or by providing a Tables.jl-compatible table table and a formula specified via @formula in Wilkinson notation as in","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"fit(BetaRegressionModel, @formula(y ~ 1 + x1 + ... + xn), table, meanlink, precisionlink; kwargs...)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"In both methods, the meanlink and precisionlink arguments are optional and, as previously mentioned, default to LogitLink() and IdentityLink(), respectively. The keyword arguments provide control over the fitting process as well as the ability to specify an offset and weights. (Note however that weights are currently unsupported.)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"The variables passed to the model, be it by way of design matrix or formula, cannot be collinear. Unlike lm from GLM.jl, which provides facilities for automatically dropping collinear variables, BetaRegression.jl does not handle this case. It's up to you, dear user, to just not do that.","category":"page"},{"location":"details/#References","page":"Details","title":"References","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"[1]: Ferrari, S. and Cribari-Neto, F. (2004). Beta Regression for Modelling Rates and Proportions. Journal of Applied Statistics, 31, issue 7, p. 799-815.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[2]: Vasconcellos, K. L. P. and Cribari-Neto F. (2005). Improved Maximum Likelihood Estimation in a New Class of Beta Regression Models. Brazilian Journal of Probability and Statistics, 19(1), 13–31.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[3]: Smithson, M. and Verkuilen, J. (2006). A Better Lemon Squeezer? Maximum-Likelihood Regression with Beta-Distributed Dependent Variables. Psychological Methods, 11(1), 54–71.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[4]: Ospina, R., Cribari-Neto, F., and Vasconcellos K. L. P. (2006). Improved Point and Interval Estimation for a Beta Regression Model. Computational Statistics & Data Analysis, 51(2), 960–981.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[5]: Simas, A. B., Barreto-Souza, W., and Rocha, A. V. (2010). Improved Estimators for a General Class of Beta Regression Models. Computational Statistics & Data Analysis, 54(2), 348–366.","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[6]: Nelder, J. A. and Wedderburn, R. W. M. (1972). Generalized Linear Models. Journal of the Royal Statistical Society. Series A (General), 135(3), 370. doi:10.2307/2344614","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[7]: McCullagh, P. and Nelder, J. A. (1989). Generalized Linear Models. 2nd Edition, Chapman and Hall, London. doi:10.1007/978-1-4899-3242-6","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"[8]: Huang, A., and Rathouz, P. J. (2017). Orthogonality of the Mean and Error Distribution in Generalized Linear Models. Communications in statistics: theory and methods, 46(7), 3290–3296.","category":"page"},{"location":"#BetaRegression.jl","page":"Home","title":"BetaRegression.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BetaRegression.jl is a package that provides beta regression functionality for the Julia language.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered in Julia's General registry. To install the package, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"BetaRegression\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or, using the Pkg REPL mode (press ]),","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add BetaRegression","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're looking for package documentation, welcome! You've found it. Documentation for the package's API is available on the API page and further information about beta regression in general and the methodology used by this package is available in Details.","category":"page"},{"location":"#Note","page":"Home","title":"Note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta regression is implemented in R in the betareg package and in Python in statsmodels. Note that BetaRegression.jl is not based on either of these (betareg in particular is GPL-licensed) nor is feature or implementation parity a goal.","category":"page"}]
}
